面向对象的高级特性:抽象类和接口
提纲:1.掌握抽象类的定义
        2.掌握抽象类的使用
        3.掌握抽象类的应用之模板设计模式(Template Pattern)
        4.掌握接口的定义
        5.掌握接口的使用
        6.了解接口应用之回调函数(Callback)
        7.掌握抽象类和接口的异同
        8.了解软件设计原则
-------------------------------------------------------------------------------------------------
知识点1.抽象类的定义
              关键字  abstract(抽象)  也是属于修饰符

              访问修饰符:private [] protected public 
              特殊修饰符:static final abstract
如何定义一个抽象类:
            public abstract class 类名{
                  //业务方法
                  //抽象方法--没有实现的方法---在方法前面加上abstract关键字
                  public abstract double area();
                  public abstract double girth();
            }
         注意:抽象方法是没有实现的,因此,抽象类"天生"就是用来被子类继承的,
                抽象方法"天生"就是用来被子类重写的!

                抽象类的特点:
                          1.抽象类不能够被实例化
                          2.抽象类可以有构造方法
                          3.一个子类如果继承了抽象父类,那么它必须要实现
                             抽象父类中所有的抽象方法,除非这个子类也是抽象类
                          4.抽象类中可以没有抽象方法,如果一个类中有抽象方法
                            那么它必然是抽象类

注意点:   修饰符使用的注意点:
                        1.修饰符之间是没有顺序的
                        2.哪些修饰符是不能混用的
                             1.final和abstract不能够同时出现
                                final修饰的类是不能够被继承的,而abstract修饰的类是抽象类,天生就是用来被子类继承的
                              2.static和abstract不能够同时出现
                                 static是没有多态的,而abstract就是为多态用的
                              3.private和默认修饰符(父子类不同包)与abstract是不能混用的
                                  这两个修饰符修饰的方法,子类是访问不到的,子类也就不能够重写父类中的方法
-----------------------------------------------------------------------------------------------------------
抽象类应用之模板设计模式(Template Pattern)
问题域:在系统中,有一个相对固定的业务流程,而让具体实现的细节延迟到子类
应用场景:有一个"顶级业务流程方法",而不必关心具体的实现
解决方案:
            1.定义一个抽象类,然后在抽象类中定义若干个抽象方法
            2.定义一个执行"顶级业务流程"的方法,按照顺序调用上面定义好的
               若干个抽象方法!
          
场景案例:电视剧
                  //抽象父类
                  public abstract class 电视剧流程{
                            //1.定义若干个流程的抽象方法
                            public abstract void 开场音乐();
                            public abstract void 上演剧情();
                            public abstract void 广告();
                            public abstract void 结束();
                            
                            //2.定义一个执行"顶级业务流程"的方法
                            public final void toMethod(){
                                      开场音乐();
                                      上演剧情();
                                      广告();
                                      结束();
                            }
                  }
               //西游记
               public class 西游记 extends 电视剧{
                          //重写抽象父类中的所有抽象方法
              }

              //测试类
              电视剧  d = new 西游记();
              d.toMethod();
---------------------------------------------------------------------------------
知识点2:接口 关键字:interface

          定义一个接口:
                      public interface 接口名{
                            //属性--接口中的属性都是公开的静态的常量  public static final  int I = 9;
                                   //--可以简写成
                                       int I = 9;
                            //方法---接口中的方法都是公开的抽象的方法
                                //public abstract void area();
                                //---可以简写成
                                 void area();
                      }
接口也是类,编译之后也是个.class文件
接口的命名规范:     IConstants IFly   
                         或者  Runable   Flyable
                   最好是以I开头或者able结尾
---------------------------------------------------------------------
接口的注意点:1.接口同样也不能够被实例化
                      2.接口中没有构造方法
                      3.接口中的属性,必须是公开的静态的常量
                             public static final int ROW =1;
                             可以简写成
                                   int ROW = 1
                             注意:一般这种常量会移植到常量接口中,JDK5.0以后又出现了枚举   代替了常量接口
                       4.接口中的方法,必须是公开的抽象方法
                               public abstract void area();
                               可以简写成:
                                  void area();
                       5.接口支持是多重继承的,也就是一个接口是可以继承
                          多个接口的,多个接口之间用逗号隔开
                       6.一个类可以实现多个接口,多个接口之间也是用逗号隔开的,
                           并且实现类要实现接口中的所有方法
                           除非它自己是抽象类.
注意点:接口与接口之间是继承关系   接口1 extends 接口2,接口3
            类与接口之间是实现关系      类 implements 接口1,接口2
----------------------------------------------------------------------------------------------------
public interface IA{
      void a();
}

public interface IB{
      void b();
}

public interface IC extends IA,IB{
        void c();
}
public class ICimpl  implements IC{
              //一个类实现了某接口,必须要实现里面的所有方法,包括这个接口从父类继承过来的方法
              void c();
              void a();
              void b();
}
----------------------------------------------------------------------------------
面向接口编程:
          1.方法的编译时类型写成接口
          2.方法的返回类型写成接口
          3.方法的参数类型写成接口
---------------------------------------------------------------------------------
接口的分类:
            1.常量接口   接口中只有常量
                    用来管理系统中所有的常量
            public interface IConstants{
                      int CAR=0;//public static final int CAR=0;
                      int PLANE = 1;
            }
            注意:在JDK5.0以后,一般使用枚举来替代常量接口的使用
                     枚举是类型安全的常量
             2.标记接口     什么都没有   既没有属性,也没有方法

             java.io.Serializable  序列化接口  就是一个标记接口
             在以后写实体类,都要求实体类实现该接口,JVM会根据类型来判断此
             对象是否符合可序列化的要求!
---------------------------------------------------------------------------------------------------------
案例分析:打招呼   人打招呼  动物打招呼
          步骤1.指定一个业务接口
                   ISayHello             sayHello(){}
           
          步骤2:person   animal 两个实现类实现该接口
          步骤3:测试
----------------------------------------------------------------------------------------------
         复杂版:
          步骤1.指定一个业务接口
                    ISayHello             sayHello(){}     
          步骤2:制定常量接口  int COM  = 0     int  SIM =1
          步骤3:制定标记接口  IsAnimal
          步骤4:得抽象出一个父类出来(SayHello)     没有方法
          步骤5:去写两个子类(SimSayHello  ComSayHello)(充当的是实现类)-----最核心
          步骤6:制定 工厂(SayHelloFactory)
          步骤7:业务方法(SayHelloBiz)
          步骤8:测试(TestSayHello)
-----------------------------------------------------------------------------------------------
总结:抽象和接口的异同
              1.相同点:
                      a.都是属于抽象类型
                      b.都不能够被实例化
               2.不同点:
                        a.抽象类中可以有构造方法,接口中没有
                        b.抽象类中可以有实现了的方法,而接口中只能是公开的抽象的方法
                        c.抽象类只支持单继承,接口支持多继承
                        d.一个类只能同时继承一个抽象类,但是可以实现多个接口,接口之间用逗号隔开
----------------------------------------------------------------------------------------------------------------------------------
软件设计原则:
            1.高内聚:
                      模块/对象之间能够独立完成业务的能力
                      模块/对象独立完成业务的能力越强,说明软件的设计越好
                      说明内聚越强
            2.低耦合
                      模块/对象之间的依赖程度
                      依赖程度越低说明软件的设计越强!
-----------------------------------------------------------------------------------------------------------
回调函数:
          所谓回调,就是客户端C去调用服务端S中的一个函数B
          ,此时S又反过来去调用C里面的函数B,我们称B
          就是回调函数!

          C不会去调用自己的函数B,C中的函数B天生就是给S来调用的

            public class Caller{
                    //1.提供一个预留接口
                    private IC ic;
                    //2.注册接口
                    public void set(IC ic){
                      this.ic = ic;
                    }

                    //3.方法
                    public void watch(){
                          System.out.println("打开电视");
                          this.ic.watch();
                           System.out.println("坐沙发");
                            System.out.println("吃薯片");
                    }
              
            }
              

              public interface IC{
                    void watch();
              }

              public class ICone implements IC{
                      //重写watch()
              }
              public class ICtwo implements IC{
                  //重写watch()方法
              }
      //测试
            Caller c = new Caller();
            c.set(new ICone());
            c.watch();


















