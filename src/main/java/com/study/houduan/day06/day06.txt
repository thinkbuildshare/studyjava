提纲:面向对象三大特征:
                      封装
                          ---封装策略   1.实体类和业务类合二为一
                                               2.实体类和业务类分开
                      继承:(Inheritance)
                             
                      多态:(polymorphic)
回顾一下:
知识点1:如何对属性进行封装:
1.把属性的访问修饰符设置成private
2.提供一个getter/setter方法来进行读取/设置值

知识点2:
比较set方法赋值和构造方法赋值:
      1.构造方法赋值只能进行一次,并且是在创建对象的时候,构造方法自己不能
        进行参数有效性判断,它要想也能实现参数有效性判断的话,需要在它里面再次
        调用set方法
       
       2.set方法可以多次赋值,并且是在它需要的时候进行赋值,并且可以进行参数有效性判断
         这也是封装的原因之一;

封装的原因:第一:保证属性的封装性;第二个可以通过set方法进行参数有效性判断!
-----------------------------------------------------------------------------------------------------------------------
封装策略:
          实体类:专门用来存储数据的,在于数据
          业务类:专门用来操作数据,操作实体类,在于功能

          策略一:
                实体类跟业务类合二为一:
                
                 public class Account{
                        private int id;
                        private String password;
                        private String name;
                        private double balance;

                        //构造
                        //getter/setter

                        //业务方法一:存钱
                        public void deposit(double money){
                              this.balance+=money;
                        }

                        //业务方法二:取钱
                        public void withdraw(double money){
                              this.balance-=money;
                        }
                 }

        策略二:实体类和业务类分开

                    实体类:
                            public class Account{
                                    //成员变量
                                    //空参构造
                                    //有参构造
                                    //getter/setter方法
                                    //toString()方法
                            }
                      
                      业务类:
                            public class AccountBiz{
                                    //存钱
                                          
                                   //取钱
                                          
                            }
-----------------------------------------------------------------------------------------------
知识点2:
        继承(Inheritance)--->关键字  extends
        在Java当中都是单继承的,C/C++是多继承的
        单继承可以保证类的层次性,不会产生网状结构
       
       注意:尽量将几个类的共性的东西抽象出来放在一个父类当中,
      

//定义一个类
      class sup{
            //共性的成员(属性+方法)
      }
//再定义一个类继承sup
    class sub extends sup{
            //个性的成员
    }

sup叫做父类,也叫做超类
sub叫做子类,也叫做派生类

这里的sup会自动去继承谁?------>java.lang.Object----->顶级类
注意点:在Java当中,当一个类没有去显式地去继承一个父类的时候,
            那么它会自动去继承java.lang.Object这个顶级类

在Java当中,虽然不支持多继承,但是我们可以有其他方法实现!(接口)
注意:一个子类有且只有一个直接的父类
但是继承具有传递性
A extends B   B extends C   也就是  A间接继承C

有了继承之后,子类可以访问父类当中非私有的成员

继承就是为了日后拓展用的
但是不能为了代码的复用而去乱继承

得考虑是否满足   A  IS  B  的这种语法
例子:                  cat is Animal
                          apple is fruit
-------------------------------------------------------------------------------------------
子类创建对象的过程:
  通过以下三个步骤,递归创建父类对象
  1.申请堆空间
  2.初始化
  3.调用构造

  super关键字
        作用一:在子类构造中,可以通过super关键字来显示调用父类中存在的有参构造
                   如果你想要调用父类中的无参构造,那么super()可以省略,并且super必须放在子类构造中的第一行;

        作用二:

方法的重写:
      条件是:出现在父子类当中

      满足条件:
              1.方法名要相同
              2.方法的返回类型要相同
              3.方法的参数列表要相同
              4.子类方法的访问修饰符的等级要小于等于父类等级
                    访问修饰符等级从低到高    public protected 默认 private
              5.子类方法抛出的异常要小于父类
引出:
        面向父类编程:
                1.方法的返回类型写成父类
                2.方法的参数类型写成父类
                3.方法的编译时类型写成父类
利用面向父类编程的思想:
  方法的编译时类型可以写成父类
    Animal  animal = new Dog();
    Animal animal = new Cat();

    这里a的编译时类型是Animal  运行时类型是Dog和Cat

    编译时类型:   对象引用的类型
    运行时类型:   对象本身真正的类型

我们的Object可以作为其他类的编译时类型

为什么要有方法的重写呢?
        一个对象,只能使用编译时类型中的非私有的属性和方法,
        如果我们用Object作为编译时类型的时候,我们只能调用Object中的方法和属性

        为了对象可以使用自己类中的特有的方法和属性,我们就选择了
        在父类当中提供这个方法,并且在子类当中对方法进行重写
        并且在调用方法的时候,它是选择的是对象本身真正的类型中
        重写的那个方法 这也是多态的特征!
-----------------------------------------------------------------------------------------
知识点3:多态
                  1.存在于继承关系
                  2.一定要有方法的重写(静态方法允许重写,但是没有多态!)

                 对象  instanceof 类型

                 注意  如果类型是对象的父类或者是对象的运行时类型
                          那么返回true,否则返回false
                          

                          java.lang.ClassCastException:





       
       

