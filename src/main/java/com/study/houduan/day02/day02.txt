数据(Data):
      我们编程是不是都是对数据进行处理.

      常量:不变的量
              整数常量:所有的整数型的数据
              小数常量:所有的小数型的数据
              字符常量:一般是用单引号 '  '
           字符串常量:一般式用双引号  "  "
           布尔常量:true false
常量定义:
final int MOTH_FIRST_DAY = 0;
常量的变量名一般是由大写和_组成  增加可读性
注意:常量一旦赋过值,后期将不能再改变
          例:final int ROW_LINE;
               ROW_LINE = 2;
---------------------------------------------------------------------------------------------
                                                

 
                                                  整数型   byte short int long
                                                  浮点型:float double
                                                  字符型:char
数据类型----1.基本类型(8种)------>       布尔类型:true false
                   
                   2.引用类型(无数种)            数组
                                                接口
                                                           内置的对象类型:Scanner  String Date()  Array  Integer
                                                            自定义的对象类型:HelloWorld  Computer Book Person Employee Customer Order
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                范围                    默认值
byte(字节型)               1个字节　8bit                    -128~127                  0 
short(短整型)              2个字节   16bit                   -2^15~2^15-1            0
int(整型)                     4个字节    32bit                  -2^31~2^31-1           0
long(长整型)               8个字节     64bit                 -2^63~2^63-1             0
float(单精度浮点型)      4个字节     32bit                  -1.798*10^-308~1.798*10^308-1                  0.0
double(双精度浮点型)   8个字节     64bit                  -3.4*10^-38~3.4*10^38-1                     0.0               
char(字符型)                 2个字节      16bit                                          '\u0000'(空格)
boolean(布尔类型)          1个字节     8bit                                            false
------------------------------------------------------------------------------------------------------------------------
变量:内存中的一块区域,类似于数学里的未知数
        语法:    数据类型  变量名 = 初始值;
                     int i = 5;//把5这个值赋给变量i
               或者:int i;//声明变量
                       i = 5;//给变量赋值

               链式的方式:int x,y,z;//先声明一个变量
                                  x = y = z = 5;//链式的方式进行赋值
             
                int a,b=5;//只是给y初始化了,但是a仍然没有初始化
                System.out.println(a);//error   注意点:要使用一个变量,前提是此变量要提前被初始化
                System.out.println(b);//OK

    赋值方式:
                    1.直接赋值
                                  int a = 10;
                     2.表达式赋值:
                                   表达式概念:由运算符和变量组成的合法的语句

                                   int i = a+b;//前提是a b都要初始化
                      3.方法赋值:
                                     int c = add(i,j);

变量名命名: 1.参照类名的规范
                    2.与类名规范不同的地方是类名首字母要大写
                       变量名是首字母要小写 并且如果是由多个单词组成
                        从第二个单词开始,每个单词的首字母要大写
                     3.变量的命名最好尽可能有意义
                        userInfo
                        1userInfo//error
                        user()Info//error
                        _abc;//OK
                        $d;//OK
 
变量的生命周期:
                        只存在于{...之内}
----------------------------------------------------------------------------------------------------
char   采用的是UNICODE编码集(统一码或者万能码)

 特殊字符:  \  叫做转义字符
            \t:    tab键
            \n:   换行  到下一行的起始位置
            \r:    换行   到当前行的其实位置
            \"     "
            \'      '
            \\\\       \\

          了解:gb2312    gbk
                  big5(台湾繁体)
                  utf-8    utf-16

                  char c='2';//ok
                  char c = 2;//OK
                  char c='我';//OK
                  char c='我们';//error  超出范围
                  char c = '\u0030';//OK
cmd中获取ascii
                        native2ascii

数据类型的转换:
                  byte->short->int->long
                  char->int->long
                  boolean->int  //error
你看到一个整数,默认是int类型
看到一个小数,默认是double类型
           隐式转换:
                         精度小的数据类型会自动转换成精度高的数据类型
                          byte b = 123;//ok    底层先看数据类型 再去检查byte是否能够盛放得下

                          int a = 3;
                          int b = 4;
                          byte c  = a+b;//因为在此处a 跟b已经是一个变量,既然是一个变量,运行的时候无法判断它是否超出byte范围
                          此处需要强转:
                              byte c = (byte)(a+b);

                          System.out.println('a');//a
                          System.out.println('a'+1);//98
                          
                          //char c = 'a';
                          char m = 'a'+1;
                          System.out.println(m);//b


                          char m='a';
                          char n = m+1;//error
                         
                      double d = .123;
            强制转换:
                        精度大的数据类型需要强制转换成精度小的数据类型
                        会造成精度丢失

注意点:精度小的数据类型和精度大的数据类型进行运算的时候,偏向精度大的那一方
             总结一下:只有D/d  L/l   F/f可以简化转换的操作
-------------------------------------------------------------------------------------------------------------------
在我们计算机当中,是以二进制(0和1组成)来存储数据
0代表整数  1代表负数
0代表false   1代表true

二进制:由0和1组成,逢2进1
 
 1000---->
 1010---->
 1111----->
 二进制与十进制之间的转换
 1111 = 1*2^3+1*2^2+1*2^1+1*2^0 = 15

 0110 1010---->1*2^6+1*2^5+0+1*2^3+0+1*2^1 = 106

8.625-------->转成二进制是多少        1000.101=1*2^3+1*2^-1+1*2^-3
                                     0.625*2=1.25
                                     0.25*2 = 0.5
                                     05*2 = 1
                                     从上往下取整数位101


十进制转二进制:
      10                       10/2          商是5  余数0
                                 5/2           商是2  余数1
                                 2/2                    1..      0
                                 1/2                  0          1
                                 将余数倒序    1010

八进制:由0-7组成   逢8进1
表示方式:032---->对应的十进制   3*8^1+2*8^0 = 26
十进制转成八进制               26----->            26/8 =   商3          余数  2
                                                                   3/8 = 0                 余数  3
                                                                   032
二进制如何转成八进制:
                110 1110--------->转成八进制:       001  101  110---->0156
                总结:八进制其实以三个二进制位为一组  1000  111
           八进制用得地方比较少
     
               1111010----------->对应的八进制    001  111  010---->0172
十六进制:由0-9和A-F表示(10-15)          
              表示0XAF----->对应的十进制是     10*16^1+15*16^0 = 175;
              十进制转成十六进制       除以16

              0x3fa1----->转换成十进制 3*16^3+15*16^2+10*16^1+1*16^0=....

 二进制如何转换成十六进制呢?
 101 1110 0010 1100----------->转成十六进制                        0X 5e2c
 总结:十六进制就是每四个二进制位为一组

 十六进制如何转换成二进制?
        将十六进制的每一位表示的数都转成相应的二进制数
        0XD28A---------->    1101   0010    1000   1010
-----------------------------------------------------------------------------------------
运算符:
            赋值运算:
                            =
                            int i = 3;//将3赋给i
              算术运算符:
                    +  相加
                    -  减
                    /   取整     8/3 = 2--------小数特殊----------9.0/2 = 4.5
                    % 取模      8%3=2
                    +=    先加然后再赋值     int i = i+3--------等同于-------int i+=3
                              面试题:
                                              short i = 3;
                                                     i = i+1;
                                                     编译不通过
                                                
                                                short i+=3;//编译通过    +=在内部帮我们作了窄化转换
                                                        
                                              +=可以屏蔽掉类型转换
                    -+
                    *=
                    /+
                    %=
                    ++                         
                                                前++:结论表达式和变量都增加
                                                          int i = 3;
                                                          int b=++i;
                                                          System.out.println(i);//4
                                                          System.out.prinln(b);//4

                                                后++:结论:变量增加,表达式不变
                                                                先赋值,再自增
                                                          int i = 3;
                                                          int b=i++;
                                                          System.out.println(i);//4
                                                          System.out.prinln(b);//3
                                                     
                    --  减减
--------------------------------------------------------------------------------------------------------------------
比较运算符:
          >
          <
          >=
          <=
         != 
         ==
---------------------------------------------------------------------------------------------------------
逻辑运算符:
          
          &&  短路与          只有两个同时为true,结果才会true

                        expr1  &&  expr2     当条件expr1能决定整个结果为fasle的时候,后面的expr2将不执行
                                                       一般我们会将出现false可能性大的一个放在前面
                                                      

          ||      短路或             只要有一个true 那么结果就是true
                                       

                                          前面的如果返回的结果如果是true,后面也将不执行
          !     非  取反
                                      boolean flag = true;
                                      !flag----->false

位运算:
          &    按位与               
          
                                                       1 0 1 0
                                                 &    1 1 0 1
                                                 -------------------
                                                        1 0 0 0      就是值
                            注意:它不管你前面的表达式返回的是true还是false,它都会去执行第二个表达式

          |      按位或
                                                
                                                       1 0 1 0
                                                 &    1 1 0 1
                                                 -------------------
                                                        1 1 1 1
          ^      异或
                            相同为 0 不同为1

                            1 0 1 0  ^  1 1 1 1 = 0101^1111=1010
                            一个数连续异或同一个数两次还是它本身

                            异或的应用:可以用来加密操作
位移的运算效率比较高
          <<    左移:           110        2<<3   = 0000  0010------->1 0000=16
                                      面试题:以最快的方式计算出4的3次方是多少
                                                         4<<4
                                    结论1:左移1位相当于乘以2

          >>    右移   在最高位补符号位
                         0000  1000   --->8>>2------>0000 0010    
                                  结论2:右移1位相当于除以2
                         0000   1010   --->10>>3------>1
                         1000    1010   ----->138>>3----->17

          >>>  不带符号右移 永远在最高位补0
                      1000  1010    ------->138>>>3------->0001 0001---->17
          ~  取反

负数在计算机当中是以补码的方式存在
                                                补码=原码取反+1

计算-6的二进制                        
                                     0000   0110
                        ~           1111   1001
                        +                           1
                        ---------------------------------
                                      1111 1010 
                        ~            0000 0101-------------->5
                        ----------------------------
结论:-6 = ~5      ~x = -(x+1)
                                                      
条件判断语句
              语法:
                              if(..布尔表达式.){
                                      .....
                              }else{
                                      ......
                              }

                              if(...){
                                      
                              }else if(){
                                
                              }else{
                                    
                              }




































