Java高级应用
            1.集合框架
            2.枚举
            3.IO流
            4.反射技术
            5.注解
            6.UML
-----------------------------------------------------------------------
集合框架(Java Collection Frame)
它是由SUM公司提供的一组操作数据的API
它是作为"容器"对象存在,可以看做是数组的拓展,
它里面有大量的接口和类
----------------------------------------------------------------------
JCF结构:
          Collection[I]
                ----List[I]
                          ------ArrayList[C]
                          ------LinkedList[C]
                          ------Vector[C]
                ----Set[I]
                          ------HashSet[C]
                          ------SortedSet[I]
                                    -----TreeSet[C]
注意点:1.List的特点是有序,可重复
           2.Set的特点是无序,不可重复
           3.SortedSet是Set的一个分支,可排序,但是不可重复
          Map[I]
                ----hashMap[C]
                ----SortedMap[I]
                        -----TreeMap[C]
          4.Map特点:是以KEY-VALUE的方式存在的,也就是说它只对
                           KEY实现无序不可重复,但是VALUE是可以重复的
注意点:Collection中存放的是值,而MAP中存放的是键值对(KEY-VALUE)
-------------------------------------------------------------------------------------------------
Collection中的公共方法:
          1.add(Object obj);//向集合中添加一个元素
          2.remove(Object obj);//移除一个元素
          3.clear();//清空集合
          4.isEmpty();//判断集合是否为空
          5.size();//获取集合容器中的元素的个数
          6.iterator();//返回集合的迭代器
          7.toArray();//转换成数组
----------------------------------------------------------------------------------------------
List[I]:有序,可重复
实现类:
          1.ArrayList
             底层是动态数组,因此它的查询效率特别高,因为数组是可以通过下标来
             查询的,但是它的增删改效率特别低,因为涉及到数组元素的移动.
          
          2.LinkedList
            底层是双向链表,它的增删改效率极高,因为只要改变相邻的节点
            但是查询效率低,因为每次都是从根节点依次往下遍历
          
          注意:根据LinkedList的特点,它适合用来做堆栈和队列的数据结构的题目
                  堆栈:先进后出
                  队列:先进先出

          3.Vector
            同ArrayList,但是Vector中的方法大都是线程安全的,也称它是多线程安全的容器
            重量级的容器
------------------------------------------------------------------------------------------------------------------------
Set[I]:无序不可重复
         实现类:
              HashSet[C]:
              底层是采用的散列表算法
                    它是与HashMap一样的,本质就是组合了HashMap的键,而Value为null
HashSet的如何实现无序不可重复的原理:
               1.当我们将一个元素添加到Set容器当中的时候,会调用该对象的
                 hashCode()方法得到一个散列码,根据散列码决定将该元素放在
                 哪个位置上!
                 当我们将第二个元素添加到Set容器当中的时候,同样也会去调用
                 该对象的hashCode()方法,同样也会得到一个散列码,如果这个散列码
                 跟容器中对象的散列码相同的话,说明这个位置被占用了,但是此时还不能
                 够确定是同一个对象,然后会去调用equals方法,如果返回true,说明是
                 同一个对象,就不会再向容器中添加,如果返回false,则会根据它自己的算法
                 分配到指定的地方!
--------------------------------------------------------------------------------------------------------------------
Sorted
      --TreeSet
            有序但是不可重复  
            底层采用的是平衡数(二叉树)算法

            它的构造方法中可以传入一个比较器来作为参数来实现有序不可重复

            方式一:java.lang.Comparable
            方式二:java.util.Comparator

            TreeSet方式二原理:
                  就是添加第二个元素的时候,每次递归调用compare()方法,来比较两个对象
-------------------------------------------------------------------------------------------------------------------------
Map[I]
      ----HashMap[C]
           特点:它是以键值对(KEY->VALUE)的形式存储数据的,底层也是散列表算法
                   并且它是对KEY实现无序不可重复,VALUE是可以重复的
           通常情况下:KEY一般是String和包装类型
                             VALUE一般是对象类型

           put(KEY,VALUE);// 将指定的值与此映射中的指定键关联（可选操作）。
           get(Object key);//通过键来获取值
           containsKey();//是否包括键
           constainsValue();//是否包括值

           注意:如果KEY相等,我们就可以把它看成是同一个对象
-----------------------------------------------------------------------------------------------------------------------------------
//迭代方法有两种
		//第一种:将Map的键存放Set集合当中,然后迭代这个Set集合来到键跟值
		Set<Integer> set = map.keySet();
		//构建集合迭代器
		Iterator<Integer> iter = set.iterator();
		while(iter.hasNext()){
			Integer key = iter.next();
			String value = map.get(key);//通过键获取值
			System.out.println(key+"---->"+value);
		}
		System.out.println("------------------------------");
		//迭代方法二:将Entry<Key,Value>键值对封装到Set集合当中
		         //然后迭代Set集合可以获取到每个Entry<Key,Value>
		         //再调用getKey()和getValue()
	    Set<Entry<Integer,String>> set2 = map.entrySet();
	    Iterator<Entry<Integer,String>> iter2 = set2.iterator();
	    while(iter2.hasNext()){
	    	Entry<Integer,String> entry = iter2.next();
	    	Integer key = entry.getKey();
	    	String value = entry.getValue();
	    	System.out.println(key+"----->"+value);
	    }
-----------------------------------------------------------------------------------------------------------------
Collections:集合的工具类
                  // 反转指定列表中元素的顺序
                  reverse()

                  //随机打乱
                  shuffle()

                  //排序
                  Collections.sort(list,比较器)
---------------------------------------------------------------------------



























