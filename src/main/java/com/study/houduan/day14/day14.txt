回顾:
     按照类型分:输入流和输出流
                        输入流的抽象父类:java.io.InputStream
                                      基础流:节点流    FileInputStream 
                                      拓展流  过滤流   BufferedInputStream

                        输入出流的抽象父类:java.io.OutputStream
     按照功能分:字节流和字符流
                        字符流:BufferedReader
                                   FileReader
                         输出:PrintWriter
                                 FileWriter
----------------------------------------------------------------------------------------------------
防止乱码:你的编码文件和解码文件的字符编码集要一致
               编码:字符->字节
               解码:字节->字符

               GBK/gb2312
               UTF-8
               Big5  繁体字
               ISO-8859-1
------------------------------------------------------------------------------
提纲:
        1.RandomAccessFile   随机访问流
        2.进程和线程的区别
        3.创建线程的两种方式
        4.线程的常用方法
        5.线程的状态
        6.线程的同步加锁
        7.线程之间的通信
        8.死锁
-------------------------------------------------------------------------
知识点1:随机访问流   RandomAccessFile
            作用:可以定位到文件中的具体的位置进行读取

构造:
      public RandomAccessFile(String path,String mode);

      mode是啥?
      是文件打开的方式
      r   只读
      rw  读写

      常用方法:
              read();//读取单个字节
              readLine();//读取一行
              seek(long l);//定位   注意:一般是先定位再读取
-------------------------------------------------------------------------------------------
Thread:
          1.进程和线程的区别:
              进程:正在运行的程序,如JVM进程,QQ进程
              线程:运行在进程的内部,共享进程,并且拥有独立的运行空间
          2.创建线程的两种方式:
                 a.继承java.lang.Thread 类
                 b.实现 java.lang.Runable 接口
          3.常用方法:
                  构造:
                      a.Thread t1 = new ThreadDemo1();
                      b.Thread t2 = new Thread(new ThreadDemo2());
                  常用方法:
                       1.currentThread();//返回当前的线程
                       2.getName();//返回当前线程的名称
                       3.getPriority() ;//获取线程的优先级  
                       4.setPriority();//设置线程的优先级[1-10]
                              注意:并不是你设置的线程的优先级越高,就一定是它先运行
                       5.interrupt() ;//中断线程
                       6.join();// 等待该线程终止   让其他线程对象调用该方法,使自己进入阻塞状态
                       7.sleep();//睡
                       8.start();//呼叫JVM去调用run方法
            4.线程的状态:
               1.初始态(Beginning)
                  Thread t1 = new ThreadDemo();
                2.就绪态(Locking),也称为可运行态
                   t1.start();
                3.运行态(Running)
                4.阻塞态
                        通常情况下,正在运行的状态在如下三种场景会进入阻塞状态
                        a.等待用户输入
                        b.sleep
                        c.调用其他线程对象t2的join方法
                    打破阻塞态,让程序重新进入运行态:
                       a.用户输入完毕
                       b.睡眠时间到了,或者被其他线程中断
                       c.t2线程运行结束,或者别其他线程中断
                 5.终止态
                   线程运行结束
                 6."锁池"
                      是一种特殊的阻塞状态,当线程来执行同步代码的时候,JVM
                      会检查该线程对象是否拥有"锁"标记,有的话,就让线程进入同步代码
                      并执行,否则,让该线程对象进入临界资源到"锁池"
                 7.等待队列
                      也是一种特殊的阻塞状态,但是JVM不会主动去调用,
                      它必须是由其他线程调用notify或者notifyAll来唤醒此
                      状态下的线程.让线程重返临界资源的"锁池"当中
多线程并发访问控制:
            当多个线程操作同一个资源的时候,如果这种操作涉及到修改之类,会造成数据不一致
            在Java中,采用"锁"机制来实现线程同步

            锁(Lock):是一种同步资源,它是对象所拥有的,并且当线程同步时,这个"锁"才会出现

           如何实现线程同步:
           关键字:synchronized

           内同步和外同步

           外同步锁加在方法上

           //相当于  将整个对象当成临界资源
            public static synchronized void withdraw(){
                  
            }

           内同步锁加在方法体中
                   public static  void withdraw(){
                          synchronized(临界资源1){
                                
                          }
                          synchronized(临界资源2){
                                
                          }
                            synchronized(临界资源3){
                                
                          }
            }

---------------------------------------------------------------------------------------------------------------------------
死锁:多个线程在同一时刻抢占同一个资源,形成了环路等待状态.
    案例:静态域会造成死锁
--------------------------------------------------------------------------------------
线程之间如何实现通行:
        notify:
                 唤醒在此对象监视器上等待的单个线程。
        notifyAll:
                唤醒在此对象监视器上等待的所有线程。
        wait:
                在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。
----------------------------------------------------------------------------------------------------------------------------------
单元测试:对程序中最小单元进行测试和验证
          白盒测试:需要代码走查
          黑盒测试:测试功能
          























